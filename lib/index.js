// Generated by CoffeeScript 1.7.1
(function() {
  var fs, path, start, util, _;

  fs = require('fs');

  path = require('path');

  _ = require('lodash');

  util = require('util');

  start = function(opts, callback) {
    var ctx, inspectOpts, loadHistory, maxCb, repl, replHistory, saveHistory, verbose, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    _ref = _.isFunction(opts) ? [{}, opts] : [opts, callback], opts = _ref[0], callback = _ref[1];
    replHistory = (_ref1 = opts.historyFile) != null ? _ref1 : "./.repl-history";
    repl = require("repl").start((_ref2 = opts.prompt) != null ? _ref2 : ">> ");
    maxCb = (_ref3 = opts.maxCb) != null ? _ref3 : 10;
    verbose = (_ref4 = opts.verbose) != null ? _ref4 : true;
    inspectOpts = {
      depth: (_ref5 = opts.depth) != null ? _ref5 : 2,
      colors: true
    };
    saveHistory = function(callback) {
      return fs.writeFile(replHistory, repl.rli.history.reverse().join('\n') + '\n', callback);
    };
    loadHistory = function(callback) {
      return fs.exists(replHistory, function(exists) {
        if (!exists) {
          return callback(null);
        }
        return fs.readFile(replHistory, {
          encoding: 'utf8'
        }, function(err, data) {
          var ex, line, lines, _i, _len;
          if (err) {
            return callback(err);
          }
          try {
            lines = data.split('\n');
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              if (!_.isEmpty(line)) {
                repl.rli.line = line;
                repl.rli._addHistory();
                repl.rli.line = '';
                repl.lines.push(line);
              }
            }
            return callback(null);
          } catch (_error) {
            ex = _error;
            return callback(ex);
          }
        });
      });
    };
    repl.on('exit', function() {
      return saveHistory(function(err) {
        if (err) {
          console.error("error writing console history: " + err);
        }
        return process.kill(process.pid, 'SIGINT');
      });
    });
    process.on('uncaughtException', function(err) {
      if (err) {
        console.error("uncaughtException: " + err);
      }
      return saveHistory(function(err) {
        if (err) {
          console.error("error writing console history: " + err);
        }
        return process.kill(process.pid, 'SIGINT');
      });
    });
    ctx = repl.context;
    ctx.lo = require('lodash');
    ctx.cb = function() {
      var i, l, message;
      l = arguments.length;
      message = "Callback called with " + l + " argument";
      if (l !== 1) {
        message += "s";
      }
      if (l > 0) {
        message += ":\n";
      }
      i = 0;
      while (i < maxCb) {
        if (i < arguments.length) {
          ctx["_" + i] = arguments[i];
          message += "_" + i + " = ";
          message += (verbose ? util.inspect(arguments[i], inspectOpts) : "" + arguments[i]);
          message += "\n";
        } else {
          if (ctx.hasOwnProperty("_" + i)) {
            delete ctx["_" + i];
          }
        }
        i += 1;
      }
      return console.log(message);
    };
    repl.defineCommand('quit', {
      help: 'Exit the repl',
      action: function() {
        return repl.rli.close();
      }
    });
    repl.defineCommand('clearHist', {
      help: 'repl history cleared',
      action: function() {
        repl.lines = [];
        repl.rli.history = repl.rli.history.slice(0, 1);
        repl.rli.historyIndex = -1;
        return console.log('console history cleared');
      }
    });
    loadHistory(function(err) {
      return callback(err, ctx);
    });
    return repl;
  };

  module.exports = {
    start: start
  };

}).call(this);
